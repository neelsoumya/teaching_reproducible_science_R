---
title: "Meta-analysis of survival models in the DataSHIELD platform"
author: "Soumya Banerjee"
date: "30 April 2021"
output:
  pdf_document:
    toc: yes
    number_sections: yes
    fig_caption: yes
  html_document:
    toc: yes
    df_print: paged
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

# Summary

This is a document that outlines technical notes and a development plan for implementing survival models
and meta-analyzing hazard ratios in the DataSHIELD platform.

# Survival analysis in DataSHIELD

We outline the development and code for implementing survival models and meta-analysis
of hazard ratios in DataSHIELD.

All code is available here:

   * https://github.com/neelsoumya/dsBaseClient/tree/absolute_newbie_client
   
   * https://github.com/neelsoumya/dsBase/tree/absolute_newbie
   
   * https://github.com/neelsoumya/datashield_testing_basic/blob/master/development_plan.rmd
   
   * https://github.com/neelsoumya/datashield_testing_basic/blob/master/development_plan.pdf
   

The computational steps are outlined below. 
The first step is connecting to the server and loading the survival data.
We assume that the reader is familiar with these details.


```{r, include = FALSE}

####################
# Load library
####################
library(knitr)
library(rmarkdown)
library(tinytex)
library(pROC)
library(precrec)
library(PRROC)
library(boot)
# LIBRARY_PREFIX <- "https://egret.psychol.cam.ac.uk/rlib/"
# source(paste0(LIBRARY_PREFIX, "cris_common.R"))

source("https://raw.githubusercontent.com/neelsoumya/rlib/master/cris_common.R")

#######################
# Get data
#######################
df_metagene_score_final = read.csv('metagene_score.csv', 
                                  sep = ',', header = TRUE, 
                                  stringsAsFactors=FALSE, na.strings="..")


```

# Visualize data

todo histogram

# Creating server-side variables for survival analysis

We now outline some steps for analysing survival data.

* make sure that the outcome variable is numeric 

```
ds.asNumeric(x.name = "D$cens",
             newobj = "EVENT",
             datasources = connections)

ds.asNumeric(x.name = "D$survtime",
             newobj = "SURVTIME",
             datasources = connections)
```

*  convert time id variable to a factor 

```

ds.asFactor(input.var.name = "D$time.id",
            newobj = "TID",
            datasources = connections)

```

*  create in the server-side the log(survtime) variable

```

ds.log(x = "D$survtime",
       newobj = "log.surv",
       datasources = connections)

```

*  create start time variable

```

ds.asNumeric(x.name = "D$starttime",
             newobj = "STARTTIME",
             datasources = connections)

ds.asNumeric(x.name = "D$endtime",
             newobj = "ENDTIME",
             datasources = connections)

```



```{r, include=FALSE}

RAIN = sample(c(TRUE,FALSE),
                  nrow(df_metagene_score_final),
                  replace = TRUE)

TEST = (!TRAIN)

df_metagene_score_final_TRAIN = df_metagene_score_final[TRAIN,]
df_metagene_score_final_TEST  = df_metagene_score_final[TEST,]

```


# Perform logistic regression


* use constructed Surv object in *coxph.SLMA()*



```{r, include=FALSE}

mylogit <- glm(flag_yes_no ~ metagene_score, 
               data = df_metagene_score_final_TRAIN, 
               family = "binomial")
               
               ######################################
# Check linear model distributions
#######################################
miscstat$check_distribution(model = glm_object_best)


#######################################
# Visualize parameter distributions
# holds for linear mixed effects models lmer()
#######################################
# cris$visualize_fixed_effects_from_lmer(lmer_result = glm_object_best)
# cris$fixed_effects_from_lmer(lmer_result = glm_object_best)


###############################
# predict on test set
###############################
prob = predict(mylogit, 
               type=c("response"),
               newdata = df_metagene_score_final_TEST)
df_metagene_score_final_TEST$prob = prob


###############################
# Additional code to do 
#   cross-validation NOT USED
# on TRAINING SET
###############################
cost <- function(r, pi=0) mean(abs(r-pi)>0.5)
cv_err <- cv.glm(data = df_metagene_score_final_TRAIN,
                 K = 4,
                 cost = cost,
                 glmfit = mylogit
)

# can use the following to perform model selection if necessary
cv_err$delta[1]


###############################
# Generate ROC curves
#   on TEST SET
###############################
g <- pROC::roc(flag_yes_no ~ prob, data=df_metagene_score_final_TEST)

plot(g)

cat("AUC is:", g$auc)


############################
# Precision recall curve
#     on test set
############################
mmdata_flag = mmdata(df_metagene_score_final_TEST$metagene_score,
                     df_metagene_score_final_TEST$flag_yes_no)
smcurves <- evalmod(mmdata_flag, raw_curves = TRUE)

# We also show the precision recall curve below 
# which is better suited for cases in which there are class imbalances.

plot(smcurves, raw_curves = FALSE)

############################
# even better AUC and AUPR 
# curves with areas reportet
#   on TEST SET
############################

fg <- prob[df_metagene_score_final_TEST$flag_yes_no == 1]
bg <- prob[df_metagene_score_final_TEST$flag_yes_no == 0]

# ROC Curve    
roc <- roc.curve(scores.class0 = fg, scores.class1 = bg, curve = TRUE)
plot(roc)

# PR Curve
pr <- pr.curve(scores.class0 = fg, scores.class1 = bg, curve = TRUE)
plot(pr)

cat("AUPR is:", pr$auc.integral)


##################################
# Better AUPR plot using ggplot
##################################
source("convert_aupr_to_ggplot.R")

i_y_line_threshold_signif_aupr = length(which(df_metagene_score_final$flag_yes_no == 1))/(length(which(df_metagene_score_final$flag_yes_no == 1)) + length(which(df_metagene_score_final$flag_yes_no == 0)))

convert_aupr_to_ggplot(i_y_line_threshold_signif=i_y_line_threshold_signif_aupr, 
                                   prroc_object=pr,
                                   str_filename_save="aupr_ggplot.pdf")

```

# Summary of survival objects

We can also summarize a server-side object of type *survival::Surv()*
using a call to *ds.summary()*. This will provide a non-disclosive
summary of the server-side object. An example call is shown below:


```

dsBaseClient::ds.summary(x = 'surv_object')

```



```{r, include=FALSE}

#################################
# summary of coxphSLMA
#################################
dsBaseClient::ds.summary(x = 'surv_object')
dsBaseClient::ds.class(x = 'surv_object')
dsBaseClient::ds.mean(x='surv_object')


#################################
# TODO: Plot survival curves
#################################
# fit <- survival::survfit(formula = 'surv_object~D$age+D$female', data = 'D')
# need ds.survfit() and survfitDS()
# fit_model <- ds.survfit(coxph_model[1])
# plot(fit_model)

# TODO:
# plot(survfit_km, fun="cloglog")

# TODO: 
# ggplot like functionality see other functions

# In dsBaseClient::
# ds.survfit()
#         datashield.aggregate("survfitDS", ....)
#          return (the fit model)

# In dsBase::
# survfitDS(coxph_model)  
#               fit_model <- survival::survfit(coxph_model, newdata = 'D')
#               return (fit_model)

dsBaseClient::ds.survfit(formula='surv_object~1', objectname='survfit_object')
# verify that object has been created
dsBaseClient::ds.ls()

# ERROR summary of survfit not allowed
# dsBaseClient::ds.summary(x='survfit_object')
# dsBaseClient::ds.mean(x='survfit_object')

```


# Diagnostics for Cox proportional hazards models

We have also created functions to test for the assumptions of 
Cox proportional hazards models.

```
dsBaseClient::ds.coxphSLMAassign(formula = 'surv_object~D$age+D$female',
                            objectname = 'coxph_serverside')

dsBaseClient::ds.cox.zphSLMA(fit = 'coxph_serverside')

dsBaseClient::ds.coxphSummary(x = 'coxph_serverside')

```

A diagnostic summary is shown below. 

```{r, echo=FALSE}

dsBaseClient::ds.coxphSLMAassign(formula = 'surv_object~D$age+D$female', objectname = 'coxph_serverside')

dsBaseClient::ds.cox.zphSLMA(fit = 'coxph_serverside')

dsBaseClient::ds.coxphSummary(x = 'coxph_serverside')

```

# Plotting of privacy-preserving survival curves

We also plot privacy preserving survival curves.

```


dsBaseClient::ds.survfit(formula='surv_object~1', objectname='survfit_object')

dsBaseClient::ds.plotsurvfit(formula = 'survfit_object')


```


```{r, echo = FALSE}

dsBaseClient::ds.plotsurvfit(formula = 'survfit_object')

```

\newpage
   
```{r, include=FALSE}

#############################################
# disconnect
#############################################
DSI::datashield.logout(conns = connections)

```


# Acknowledgements

We acknowledge the help and support of the DataSHIELD technical team.
We are especially grateful to Paul Burton, Demetris Avraam, Stuart Wheater and
Patricia Ryser-Welch for fruitful discussions and feedback.


# References

  * https://github.com/datashield
  
  * http://www.metafor-project.org
  
  * https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6015946
  
  
  
  
